---
phase: 09-sharing-tv-mode-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/tv-mode.ts
  - src/App.ts
  - src/styles/happy-theme.css
autonomous: true
requirements:
  - TV-01
  - TV-02
  - TV-03

must_haves:
  truths:
    - "User can enter a full-screen TV/ambient mode that auto-cycles between panels at a configurable interval"
    - "TV mode uses larger typography, hides interactive elements (filter bars, resize handles, buttons), and feels like a lean-back experience"
    - "Subtle CSS-only ambient animations (floating particles, gentle panel transitions) create a warm background feel"
    - "User can exit TV mode via Escape key, a visible exit button, or by pressing the TV mode button again"
  artifacts:
    - path: "src/services/tv-mode.ts"
      provides: "TvModeController class managing panel cycling, fullscreen, and interval configuration"
      exports: ["TvModeController"]
    - path: "src/App.ts"
      provides: "TV mode button in header, keyboard shortcut, controller lifecycle wiring"
      contains: "tvMode"
    - path: "src/styles/happy-theme.css"
      provides: "TV mode CSS overrides for typography, interactivity suppression, ambient particles, panel transitions"
      contains: "data-tv-mode"
  key_links:
    - from: "src/App.ts"
      to: "src/services/tv-mode.ts"
      via: "import TvModeController, instantiate on TV button click"
      pattern: "TvModeController"
    - from: "src/services/tv-mode.ts"
      to: "document.documentElement.dataset.tvMode"
      via: "data-tv-mode attribute drives CSS cascade"
      pattern: "dataset.tvMode"
    - from: "src/styles/happy-theme.css"
      to: "[data-tv-mode]"
      via: "CSS selectors scope all TV mode visual overrides"
      pattern: "data-tv-mode"
---

<objective>
Build a fullscreen TV/ambient mode for the happy variant — a lean-back experience that auto-cycles between panels with larger typography, suppressed interactive elements, and subtle CSS-only ambient animations.

Purpose: Users want to put HappyMonitor on a TV or second monitor as a positive ambient display that cycles through good news, progress charts, species data, and energy stats.

Output: `src/services/tv-mode.ts` (TvModeController class), updated `src/App.ts` (TV button + wiring), updated `src/styles/happy-theme.css` (TV mode CSS).
</objective>

<execution_context>
@/Users/sebastienmelki/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastienmelki/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/App.ts (header HTML, fullscreen toggle, panel creation, happy variant branching)
@src/components/Panel.ts (show/hide/destroy lifecycle, .hidden class pattern)
@src/config/panels.ts (HAPPY_PANELS — 9 panels including map)
@src/styles/happy-theme.css (all happy variant CSS overrides)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TvModeController and CSS-only ambient styling</name>
  <files>src/services/tv-mode.ts, src/styles/happy-theme.css</files>
  <action>
**Create `src/services/tv-mode.ts`:**

Export a `TvModeController` class:

```typescript
export class TvModeController {
  private intervalId: ReturnType<typeof setInterval> | null = null;
  private currentIndex = 0;
  private panelKeys: string[];
  private intervalMs: number;
  private onPanelChange?: (key: string) => void;
  private boundKeyHandler: (e: KeyboardEvent) => void;

  constructor(opts: {
    panelKeys: string[];       // Panel IDs to cycle through (from HAPPY_PANELS keys)
    intervalMs?: number;       // Default 60000 (1 min)
    onPanelChange?: (key: string) => void;  // Callback when active panel changes
  })
}
```

**Methods:**

- `enter()`: Set `document.documentElement.dataset.tvMode = 'true'`. Request fullscreen via existing pattern (reuse toggleFullscreen logic — copy the 4-line snippet, do NOT import from App since it's a private method). Start cycling interval. Show first panel. Add keydown listener for Escape (calls `exit()`).
- `exit()`: Delete `document.documentElement.dataset.tvMode`. Exit fullscreen if active. Clear interval. Remove keydown listener. Call `showAllPanels()` to restore grid.
- `toggle()`: If active (`dataset.tvMode`), call `exit()`, else `enter()`.
- `get active(): boolean`: Returns `!!document.documentElement.dataset.tvMode`.
- `setInterval(ms: number)`: Update interval. Persist to `localStorage` key `'tv-mode-interval'`. If cycling, clear and restart interval.
- `destroy()`: Call `exit()`, null out references.

**Panel cycling logic:**

- `showPanel(index)`: Find `#panelsGrid`, query all `.panel` children. Add class `tv-hidden` to all except the current index. Add class `tv-active` to the current panel. Also handle the map section (`#mapSection`) — when index 0 (map), show map section and hide panels grid; for other indices, hide map section and show panels grid. Call `onPanelChange` callback with the panel key.
- `nextPanel()`: Increment index mod panelKeys.length, call showPanel.
- `showAllPanels()`: Remove `tv-hidden` and `tv-active` classes from all panels. Show both map section and panels grid.

**Interval config:**
- Read initial interval from `localStorage.getItem('tv-mode-interval')` parsed as int, default 60000.
- Clamp to range 30000–120000 (30s–2min per requirement).

**In `happy-theme.css`, add TV mode styles:**

1. **Panel cycling transitions:**
```css
[data-tv-mode] .panel {
  transition: opacity 0.8s ease, transform 0.5s ease;
}
[data-tv-mode] .panel.tv-hidden {
  opacity: 0;
  position: absolute;
  pointer-events: none;
  height: 0;
  overflow: hidden;
}
[data-tv-mode] .panel.tv-active {
  opacity: 1;
  width: 100%;
  max-width: 100%;
}
```

2. **Larger typography (TV-02):**
```css
[data-tv-mode] .panel-title { font-size: 1.6rem; }
[data-tv-mode] .panel-content { font-size: 1.15rem; line-height: 1.7; }
[data-tv-mode] .positive-card-title { font-size: 1.3rem; }
[data-tv-mode] .counter-value { font-size: 2.4rem; }
[data-tv-mode] .counter-label { font-size: 1.1rem; }
```

3. **Suppressed interactive elements (TV-02):**
```css
[data-tv-mode] .positive-filter-bar,
[data-tv-mode] .map-resize-handle,
[data-tv-mode] .positive-card-share,
[data-tv-mode] .panel-header button,
[data-tv-mode] .settings-btn,
[data-tv-mode] .sources-btn,
[data-tv-mode] .search-btn,
[data-tv-mode] .copy-link-btn,
[data-tv-mode] .fullscreen-btn,
[data-tv-mode] #regionSelect,
[data-tv-mode] #langSelect {
  display: none !important;
}
```

4. **Layout overrides for single-panel display:**
```css
[data-tv-mode] #panelsGrid {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0;
}
[data-tv-mode] .panel.tv-active {
  min-height: calc(100vh - 60px);
  display: flex;
  flex-direction: column;
}
[data-tv-mode] .panel.tv-active .panel-content {
  flex: 1;
  overflow: auto;
}
```

5. **Ambient floating particles (TV-03) — CSS-only with pseudo-elements:**
```css
[data-tv-mode]::before,
[data-tv-mode]::after {
  content: '';
  position: fixed;
  border-radius: 50%;
  pointer-events: none;
  z-index: 0;
  opacity: 0.04;
}
[data-tv-mode]::before {
  width: 300px;
  height: 300px;
  background: radial-gradient(circle, var(--yellow) 0%, transparent 70%);
  top: 10%;
  left: 5%;
  animation: tv-float-a 25s ease-in-out infinite alternate;
}
[data-tv-mode]::after {
  width: 250px;
  height: 250px;
  background: radial-gradient(circle, var(--green) 0%, transparent 70%);
  bottom: 15%;
  right: 8%;
  animation: tv-float-b 30s ease-in-out infinite alternate;
}
@keyframes tv-float-a {
  0% { transform: translate(0, 0) scale(1); }
  50% { transform: translate(60px, 40px) scale(1.2); }
  100% { transform: translate(-30px, 80px) scale(0.9); }
}
@keyframes tv-float-b {
  0% { transform: translate(0, 0) scale(1); }
  50% { transform: translate(-50px, -30px) scale(1.15); }
  100% { transform: translate(40px, -60px) scale(0.95); }
}
```

6. **Reduced motion support:**
```css
@media (prefers-reduced-motion: reduce) {
  [data-tv-mode]::before,
  [data-tv-mode]::after {
    animation: none;
  }
  [data-tv-mode] .panel {
    transition: none;
  }
}
```

7. **TV mode exit button (always visible in TV mode):**
```css
[data-tv-mode] .tv-exit-btn {
  display: flex !important;
  position: fixed;
  bottom: 24px;
  right: 24px;
  z-index: 9999;
  background: rgba(0,0,0,0.5);
  color: #fff;
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 8px;
  padding: 8px 16px;
  font-size: 14px;
  cursor: pointer;
  opacity: 0;
  transition: opacity 0.3s;
}
[data-tv-mode]:hover .tv-exit-btn {
  opacity: 1;
}
.tv-exit-btn {
  display: none !important;
}
```

Keep the ambient particles intentionally subtle (opacity 0.04) per the "warm, not birthday party" constraint.
  </action>
  <verify>
`npx tsc --noEmit src/services/tv-mode.ts` compiles. The CSS rules in happy-theme.css are valid (no syntax errors). Verify `[data-tv-mode]` selectors are properly scoped.
  </verify>
  <done>
TvModeController class manages fullscreen, panel cycling with configurable interval, and keyboard exit. CSS provides larger typography, hidden interactive elements, smooth panel transitions, and subtle ambient floating particle animations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire TV mode into App.ts header and lifecycle</name>
  <files>src/App.ts</files>
  <action>
**Add TV mode button to header (happy variant only):**

In the `renderHeader()` HTML template (around line 1939, in `.header-right`), add a TV mode button right before the fullscreen button, gated on `SITE_VARIANT === 'happy'`:

```typescript
${SITE_VARIANT === 'happy' ? `<button class="tv-mode-btn" id="tvModeBtn" title="TV Mode (Shift+T)">
  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
    <line x1="8" y1="21" x2="16" y2="21"/>
    <line x1="12" y1="17" x2="12" y2="21"/>
  </svg>
</button>` : ''}
```

Also add a TV exit button in the main HTML body (outside header, at top level of app HTML):
```html
<button class="tv-exit-btn" id="tvExitBtn">Exit TV Mode</button>
```

**Add TV mode button styling in happy-theme.css:**
Style `.tv-mode-btn` to match existing header buttons (same pattern as `.fullscreen-btn`):
- Same size, padding, color, hover as the fullscreen button
- Add `.tv-mode-btn.active` state with golden glow or gold text color

**Add property and lifecycle wiring in App.ts:**

1. Add `private tvMode: TvModeController | null = null;` property
2. Import `TvModeController` from `@/services/tv-mode`
3. In `setupEventListeners()` (after fullscreen toggle setup), add:
   ```typescript
   // TV Mode (happy variant only)
   if (SITE_VARIANT === 'happy') {
     const tvBtn = document.getElementById('tvModeBtn');
     const tvExitBtn = document.getElementById('tvExitBtn');
     if (tvBtn) {
       tvBtn.addEventListener('click', () => this.toggleTvMode());
     }
     if (tvExitBtn) {
       tvExitBtn.addEventListener('click', () => this.toggleTvMode());
     }
     // Keyboard shortcut: Shift+T
     document.addEventListener('keydown', (e) => {
       if (e.shiftKey && e.key === 'T' && !e.ctrlKey && !e.metaKey && !e.altKey) {
         const active = document.activeElement;
         if (active?.tagName !== 'INPUT' && active?.tagName !== 'TEXTAREA') {
           e.preventDefault();
           this.toggleTvMode();
         }
       }
     });
   }
   ```

4. Add `private toggleTvMode()` method:
   ```typescript
   private toggleTvMode(): void {
     if (!this.tvMode) {
       // Get panel keys from HAPPY_PANELS, map is first
       const panelKeys = Object.keys(DEFAULT_PANELS);
       this.tvMode = new TvModeController({
         panelKeys,
         onPanelChange: (key) => {
           // Update TV button state
           document.getElementById('tvModeBtn')?.classList.toggle('active', this.tvMode?.active ?? false);
         }
       });
     }
     this.tvMode.toggle();
     document.getElementById('tvModeBtn')?.classList.toggle('active', this.tvMode.active);
   }
   ```

5. In `destroy()` method, add cleanup: `this.tvMode?.destroy(); this.tvMode = null;`
  </action>
  <verify>
`npm run build:happy` succeeds. In the happy variant header, a TV icon button appears next to the fullscreen button. Clicking it enters fullscreen TV mode with panel cycling. Pressing Escape or clicking the exit button returns to normal view. Pressing Shift+T toggles TV mode.
  </verify>
  <done>
TV mode is fully wired into the happy variant with header button, exit button, Shift+T keyboard shortcut, and proper lifecycle cleanup. The button shows active state when TV mode is on.
  </done>
</task>

</tasks>

<verification>
1. `npm run build:happy` completes without errors
2. TV mode button visible in happy variant header (not visible in other variants)
3. Clicking TV button enters fullscreen, shows first panel (map) filling the screen
4. Panels auto-cycle at 60s intervals (or configured interval)
5. Interactive elements (filter bars, resize handles, settings button) are hidden in TV mode
6. Typography is visibly larger in TV mode
7. Subtle ambient floating particles visible in background (very low opacity)
8. Escape key or exit button leaves TV mode and restores normal grid layout
9. Shift+T keyboard shortcut toggles TV mode
10. `prefers-reduced-motion` disables ambient animations
</verification>

<success_criteria>
- TvModeController manages fullscreen + panel cycling with 30s–2min configurable interval
- CSS `[data-tv-mode]` attribute drives all visual overrides via pure CSS cascade
- Ambient particles are CSS-only (no JS particle library), subtle opacity 0.04
- All interactive elements hidden; typography scaled up
- Multiple exit paths: Escape, exit button, TV button, Shift+T
</success_criteria>

<output>
After completion, create `.planning/phases/09-sharing-tv-mode-polish/09-02-SUMMARY.md`
</output>
